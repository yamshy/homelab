---
description: "Kubernetes resource patterns, naming conventions, and best practices for homelab cluster management"
alwaysApply: false
globs:
  - "kubernetes/**/*.yaml"
  - "kubernetes/**/*.yml"
  - "kubernetes/apps/**/*.yaml"
  - "kubernetes/apps/**/*.yml"
  - "kubernetes/components/**/*.yaml"
  - "kubernetes/components/**/*.yml"
  - "kubernetes/clusters/**/*.yaml"
  - "kubernetes/clusters/**/*.yml"
  - "kubernetes/flux/**/*.yaml"
  - "kubernetes/flux/**/*.yml"

---
# Kubernetes Resource Patterns

## Resource Organization

### Namespace Strategy

- **kube-system**: Core Kubernetes and system components
- **flux-system**: Flux operator and GitOps management
- **cert-manager**: Certificate management and TLS
- **longhorn-system**: Storage management
- **default**: User applications and services
- **network**: Networking and ingress components

### Resource Naming Conventions

- **Applications**: Use kebab-case (e.g., `my-app`, `postgresql`)
- **Resources**: Follow Kubernetes conventions (e.g., `my-app-deployment`, `my-app-service`)
- **Labels**: Use consistent label schemes across resources
- **Annotations**: Include relevant metadata and configuration

## Common Resource Patterns

### 1. HelmRelease Resources

Applications use Flux HelmReleases for deployment:

```yaml
apiVersion: helm.toolkit.fluxcd.io/v2
kind: HelmRelease
metadata:
  name: app-name
  namespace: app-namespace
  labels:
    app.kubernetes.io/name: app-name
    app.kubernetes.io/instance: app-name
spec:
  interval: 1h
  chartRef:
    kind: OCIRepository
    name: app-name
  install:
    remediation:
      retries: -1
  upgrade:
    cleanupOnFail: true
    remediation:
      retries: 3
  valuesFrom:
    - kind: ConfigMap
      name: app-name-values
```

### 2. Service Configuration

Standard service patterns for applications:

```yaml
apiVersion: v1
kind: Service
metadata:
  name: app-name
  namespace: app-namespace
  labels:
    app.kubernetes.io/name: app-name
spec:
  type: ClusterIP
  ports:
    - name: http
      port: 80
      targetPort: 8080
      protocol: TCP
  selector:
    app.kubernetes.io/name: app-name
```

### 3. Ingress Resources

HTTP routing with cert-manager integration:

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: app-name
  namespace: app-namespace
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-prod
    kubernetes.io/ingress.class: cilium
spec:
  tls:
    - hosts:
        - app.example.com
      secretName: app-name-tls
  rules:
    - host: app.example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: app-name
                port:
                  number: 80
```

### 4. Persistent Volume Claims

Storage configuration with Longhorn:

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: app-data
  namespace: app-namespace
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
  # Uses default Longhorn storage class
  # storageClassName: longhorn  # Optional, explicit specification
```

## Resource Management Patterns

### 1. Kustomization Structure

App-level kustomization files organize resources:

```yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
resources:
  - ./helmrelease.yaml
  - ./service.yaml
  - ./ingress.yaml
  - ./pvc.yaml
configMapGenerator:
  - name: app-name-values
    files:
      - values.yaml=./helm/values.yaml
configurations:
  - ./helm/kustomizeconfig.yaml
```

### 2. ConfigMap Generation

Helm values stored in generated ConfigMaps:

```yaml
# In app-level kustomization.yaml
configMapGenerator:
  - name: app-name-values
    files:
      - values.yaml=./helm/values.yaml

# Referenced in HelmRelease
spec:
  valuesFrom:
    - kind: ConfigMap
      name: app-name-values
```

### 3. Secret Management

SOPS-encrypted secrets for sensitive data:

```yaml
# Encrypted with SOPS
apiVersion: v1
kind: Secret
metadata:
  name: app-secrets
  namespace: app-namespace
type: Opaque
data:
  username: <encrypted>
  password: <encrypted>
```

## Common Application Patterns

### 1. Database Applications

```yaml
# StatefulSet for databases
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgresql
spec:
  serviceName: postgresql
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: postgresql
  template:
    metadata:
      labels:
        app.kubernetes.io/name: postgresql
    spec:
      containers:
        - name: postgresql
          image: postgres:15
          ports:
            - containerPort: 5432
          volumeMounts:
            - name: data
              mountPath: /var/lib/postgresql/data
  volumeClaimTemplates:
    - metadata:
        name: data
      spec:
        accessModes: [ReadWriteOnce]
        resources:
          requests:
            storage: 20Gi
```

### 2. Web Applications

```yaml
# Deployment for web apps
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app.kubernetes.io/name: web-app
  template:
    metadata:
      labels:
        app.kubernetes.io/name: web-app
    spec:
      containers:
        - name: web-app
          image: nginx:alpine
          ports:
            - containerPort: 80
          resources:
            requests:
              memory: "64Mi"
              cpu: "250m"
            limits:
              memory: "128Mi"
              cpu: "500m"
```

## Resource Validation

### Pre-deployment Checks

```bash
# Validate YAML syntax
kubectl apply --dry-run=client -f kubernetes/

# Check specific resources
kubectl apply --dry-run=client -f kubernetes/apps/default/my-app/

# Validate with kustomize
kubectl kustomize kubernetes/apps/default/my-app/ | kubectl apply --dry-run=client -f -
```

### Runtime Validation

```bash
# Check resource status
kubectl get all -n <namespace>

# Verify resource configuration
kubectl describe <resource> <name> -n <namespace>

# Check resource events
kubectl get events -n <namespace> --sort-by='.lastTimestamp'
```

## Best Practices

### Resource Design

- **Single Responsibility**: Each resource should have one clear purpose
- **Consistent Labeling**: Use standard Kubernetes labels
- **Resource Limits**: Always set resource requests and limits
- **Health Checks**: Include readiness and liveness probes

### Security

- **RBAC**: Implement appropriate role-based access control
- **Network Policies**: Use Cilium network policies for traffic control
- **Secret Management**: Encrypt all sensitive data with SOPS
- **Image Security**: Pin container image versions and use trusted sources

### Monitoring

- **Metrics**: Enable metrics collection where possible
- **Logging**: Configure proper logging for applications
- **Health Checks**: Include health checks in Flux Kustomizations
- **Resource Monitoring**: Monitor resource usage and limits

# Kubernetes Resource Patterns

## Resource Organization

### Namespace Strategy

- **kube-system**: Core Kubernetes and system components
- **flux-system**: Flux operator and GitOps management
- **cert-manager**: Certificate management and TLS
- **longhorn-system**: Storage management
- **default**: User applications and services
- **network**: Networking and ingress components

### Resource Naming Conventions

- **Applications**: Use kebab-case (e.g., `my-app`, `postgresql`)
- **Resources**: Follow Kubernetes conventions (e.g., `my-app-deployment`, `my-app-service`)
- **Labels**: Use consistent label schemes across resources
- **Annotations**: Include relevant metadata and configuration

## Common Resource Patterns

### 1. HelmRelease Resources

Applications use Flux HelmReleases for deployment:

```yaml
apiVersion: helm.toolkit.fluxcd.io/v2
kind: HelmRelease
metadata:
  name: app-name
  namespace: app-namespace
  labels:
    app.kubernetes.io/name: app-name
    app.kubernetes.io/instance: app-name
spec:
  interval: 1h
  chartRef:
    kind: OCIRepository
    name: app-name
  install:
    remediation:
      retries: -1
  upgrade:
    cleanupOnFail: true
    remediation:
      retries: 3
  valuesFrom:
    - kind: ConfigMap
      name: app-name-values
```

### 2. Service Configuration

Standard service patterns for applications:

```yaml
apiVersion: v1
kind: Service
metadata:
  name: app-name
  namespace: app-namespace
  labels:
    app.kubernetes.io/name: app-name
spec:
  type: ClusterIP
  ports:
    - name: http
      port: 80
      targetPort: 8080
      protocol: TCP
  selector:
    app.kubernetes.io/name: app-name
```

### 3. Ingress Resources

HTTP routing with cert-manager integration:

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: app-name
  namespace: app-namespace
  annotations:
    cert-manager.io/cluster-issuer: letsencrypt-prod
    kubernetes.io/ingress.class: cilium
spec:
  tls:
    - hosts:
        - app.example.com
      secretName: app-name-tls
  rules:
    - host: app.example.com
      http:
        paths:
          - path: /
            pathType: Prefix
            backend:
              service:
                name: app-name
                port:
                  number: 80
```

### 4. Persistent Volume Claims

Storage configuration with Longhorn:

```yaml
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: app-data
  namespace: app-namespace
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 10Gi
  # Uses default Longhorn storage class
  # storageClassName: longhorn  # Optional, explicit specification
```

## Resource Management Patterns

### 1. Kustomization Structure

App-level kustomization files organize resources:

```yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization
resources:
  - ./helmrelease.yaml
  - ./service.yaml
  - ./ingress.yaml
  - ./pvc.yaml
configMapGenerator:
  - name: app-name-values
    files:
      - values.yaml=./helm/values.yaml
configurations:
  - ./helm/kustomizeconfig.yaml
```

### 2. ConfigMap Generation

Helm values stored in generated ConfigMaps:

```yaml
# In app-level kustomization.yaml
configMapGenerator:
  - name: app-name-values
    files:
      - values.yaml=./helm/values.yaml

# Referenced in HelmRelease
spec:
  valuesFrom:
    - kind: ConfigMap
      name: app-name-values
```

### 3. Secret Management

SOPS-encrypted secrets for sensitive data:

```yaml
# Encrypted with SOPS
apiVersion: v1
kind: Secret
metadata:
  name: app-secrets
  namespace: app-namespace
type: Opaque
data:
  username: <encrypted>
  password: <encrypted>
```

## Common Application Patterns

### 1. Database Applications

```yaml
# StatefulSet for databases
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: postgresql
spec:
  serviceName: postgresql
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: postgresql
  template:
    metadata:
      labels:
        app.kubernetes.io/name: postgresql
    spec:
      containers:
        - name: postgresql
          image: postgres:15
          ports:
            - containerPort: 5432
          volumeMounts:
            - name: data
              mountPath: /var/lib/postgresql/data
  volumeClaimTemplates:
    - metadata:
        name: data
      spec:
        accessModes: [ReadWriteOnce]
        resources:
          requests:
            storage: 20Gi
```

### 2. Web Applications

```yaml
# Deployment for web apps
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app.kubernetes.io/name: web-app
  template:
    metadata:
      labels:
        app.kubernetes.io/name: web-app
    spec:
      containers:
        - name: web-app
          image: nginx:alpine
          ports:
            - containerPort: 80
          resources:
            requests:
              memory: "64Mi"
              cpu: "250m"
            limits:
              memory: "128Mi"
              cpu: "500m"
```

## Resource Validation

### Pre-deployment Checks

```bash
# Validate YAML syntax
kubectl apply --dry-run=client -f kubernetes/

# Check specific resources
kubectl apply --dry-run=client -f kubernetes/apps/default/my-app/

# Validate with kustomize
kubectl kustomize kubernetes/apps/default/my-app/ | kubectl apply --dry-run=client -f -
```

### Runtime Validation

```bash
# Check resource status
kubectl get all -n <namespace>

# Verify resource configuration
kubectl describe <resource> <name> -n <namespace>

# Check resource events
kubectl get events -n <namespace> --sort-by='.lastTimestamp'
```

## Best Practices

### Resource Design

- **Single Responsibility**: Each resource should have one clear purpose
- **Consistent Labeling**: Use standard Kubernetes labels
- **Resource Limits**: Always set resource requests and limits
- **Health Checks**: Include readiness and liveness probes

### Security

- **RBAC**: Implement appropriate role-based access control
- **Network Policies**: Use Cilium network policies for traffic control
- **Secret Management**: Encrypt all sensitive data with SOPS
- **Image Security**: Pin container image versions and use trusted sources

### Monitoring

- **Metrics**: Enable metrics collection where possible
- **Logging**: Configure proper logging for applications
- **Health Checks**: Include health checks in Flux Kustomizations
- **Resource Monitoring**: Monitor resource usage and limits
