---
alwaysApply: false
description: "Generic device plugin patterns for exposing host hardware devices to Kubernetes pods, including DaemonSet configuration and resource management"

---

# Generic Device Plugin Patterns

## Overview
Generic device plugins expose host hardware devices to Kubernetes pods, enabling applications to access specialized hardware resources like TUN devices, GPUs, or other custom devices.

## Implementation Pattern

### 1. File Structure
```
kubernetes/apps/kube-system/generic-device-plugin/
├── ks.yaml              # Flux Kustomization
└── daemonset.yaml       # Device plugin DaemonSet
```

### 2. Flux Kustomization (ks.yaml)
```yaml
apiVersion: kustomize.toolkit.fluxcd.io/v1
kind: Kustomization
metadata:
  name: &app generic-device-plugin
  namespace: &namespace kube-system
spec:
  targetNamespace: *namespace
  path: ./kubernetes/apps/kube-system/generic-device-plugin
  prune: true
  interval: 1h
```

### 3. DaemonSet Configuration
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: generic-device-plugin
  namespace: kube-system
spec:
  selector:
    matchLabels:
      app: generic-device-plugin
  template:
    spec:
      priorityClassName: system-node-critical
      tolerations:
      - operator: "Exists"
        effect: "NoExecute"
      - operator: "Exists"
        effect: "NoSchedule"
      containers:
      - name: generic-device-plugin
        image: ghcr.io/squat/generic-device-plugin:latest
        securityContext:
          privileged: true
        volumeMounts:
        - name: device-plugins
          mountPath: /var/lib/kubelet/device-plugins
        - name: dev
          mountPath: /dev
      volumes:
      - name: device-plugins
        hostPath:
          path: /var/lib/kubelet/device-plugins
      - name: dev
        hostPath:
          path: /dev
      nodeSelector:
        kubernetes.io/os: linux
```

## Device Configuration

### TUN Device Example
```yaml
args:
- "--device"
- |
  name: tun
  groups:
  - count: 1000
    paths:
    - path: /dev/net/tun
```

### Resource Naming Convention
- **Format**: `squat.ai/{device-name}`
- **Example**: `squat.ai/tun` for TUN devices
- **Count**: Use `1k` (1000) for unlimited device instances

## Integration with Applications

### 1. Resource Request in Pod Spec
```yaml
resources:
  limits:
    squat.ai/tun: "1"
  requests:
    squat.ai/tun: "1"
```

### 2. Security Context Requirements
```yaml
securityContext:
  privileged: true
  capabilities:
    add: ["NET_ADMIN", "NET_RAW"]
```

## Best Practices

### 1. Namespace Placement
- **Device Plugins**: Deploy in `kube-system` namespace
- **Applications**: Deploy in application-specific namespaces
- **Resource Access**: Device resources are cluster-wide

### 2. Node Coverage
- **DaemonSet**: Ensures plugin runs on all nodes
- **Tolerations**: Include control plane and worker node tolerations
- **Node Selector**: Limit to appropriate OS (e.g., `kubernetes.io/os: linux`)

### 3. Resource Management
- **Count**: Set appropriate device count per node
- **Monitoring**: Track device usage and availability
- **Cleanup**: Ensure proper cleanup when devices are no longer needed

## Common Use Cases
1. **TUN Devices**: For VPN and networking applications
2. **Custom Hardware**: For specialized compute resources
3. **Device Passthrough**: For direct hardware access
4. **Resource Isolation**: For multi-tenant device sharing
# Generic Device Plugin Patterns

## Overview
Generic device plugins expose host hardware devices to Kubernetes pods, enabling applications to access specialized hardware resources like TUN devices, GPUs, or other custom devices.

## Implementation Pattern

### 1. File Structure
```
kubernetes/apps/kube-system/generic-device-plugin/
├── ks.yaml              # Flux Kustomization
└── daemonset.yaml       # Device plugin DaemonSet
```

### 2. Flux Kustomization (ks.yaml)
```yaml
apiVersion: kustomize.toolkit.fluxcd.io/v1
kind: Kustomization
metadata:
  name: &app generic-device-plugin
  namespace: &namespace kube-system
spec:
  targetNamespace: *namespace
  path: ./kubernetes/apps/kube-system/generic-device-plugin
  prune: true
  interval: 1h
```

### 3. DaemonSet Configuration
```yaml
apiVersion: apps/v1
kind: DaemonSet
metadata:
  name: generic-device-plugin
  namespace: kube-system
spec:
  selector:
    matchLabels:
      app: generic-device-plugin
  template:
    spec:
      priorityClassName: system-node-critical
      tolerations:
      - operator: "Exists"
        effect: "NoExecute"
      - operator: "Exists"
        effect: "NoSchedule"
      containers:
      - name: generic-device-plugin
        image: ghcr.io/squat/generic-device-plugin:latest
        securityContext:
          privileged: true
        volumeMounts:
        - name: device-plugins
          mountPath: /var/lib/kubelet/device-plugins
        - name: dev
          mountPath: /dev
      volumes:
      - name: device-plugins
        hostPath:
          path: /var/lib/kubelet/device-plugins
      - name: dev
        hostPath:
          path: /dev
      nodeSelector:
        kubernetes.io/os: linux
```

## Device Configuration

### TUN Device Example
```yaml
args:
- "--device"
- |
  name: tun
  groups:
  - count: 1000
    paths:
    - path: /dev/net/tun
```

### Resource Naming Convention
- **Format**: `squat.ai/{device-name}`
- **Example**: `squat.ai/tun` for TUN devices
- **Count**: Use `1k` (1000) for unlimited device instances

## Integration with Applications

### 1. Resource Request in Pod Spec
```yaml
resources:
  limits:
    squat.ai/tun: "1"
  requests:
    squat.ai/tun: "1"
```

### 2. Security Context Requirements
```yaml
securityContext:
  privileged: true
  capabilities:
    add: ["NET_ADMIN", "NET_RAW"]
```

## Best Practices

### 1. Namespace Placement
- **Device Plugins**: Deploy in `kube-system` namespace
- **Applications**: Deploy in application-specific namespaces
- **Resource Access**: Device resources are cluster-wide

### 2. Node Coverage
- **DaemonSet**: Ensures plugin runs on all nodes
- **Tolerations**: Include control plane and worker node tolerations
- **Node Selector**: Limit to appropriate OS (e.g., `kubernetes.io/os: linux`)

### 3. Resource Management
- **Count**: Set appropriate device count per node
- **Monitoring**: Track device usage and availability
- **Cleanup**: Ensure proper cleanup when devices are no longer needed

## Common Use Cases
1. **TUN Devices**: For VPN and networking applications
2. **Custom Hardware**: For specialized compute resources
3. **Device Passthrough**: For direct hardware access
4. **Resource Isolation**: For multi-tenant device sharing
